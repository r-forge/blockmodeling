% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stochBlock.r
\name{stochBlockORP}
\alias{stochBlockORP}
\title{A function for optimizing multiple random partitions using stochastic one-mode and linked blockmodeling. Similar to optRandomParC, but calling stochBlock for optimizing individual partitions.}
\usage{
stochBlockORP(
  M,
  k,
  rep,
  save.initial.param = TRUE,
  deleteMs = TRUE,
  max.iden = 10,
  return.all = FALSE,
  return.err = TRUE,
  seed = NULL,
  RandomSeed = NULL,
  parGenFun = blockmodeling::genRandomPar,
  mingr = NULL,
  maxgr = NULL,
  addParam = list(genPajekPar = TRUE, probGenMech = NULL),
  maxTriesToFindNewPar = rep * 10,
  skip.par = NULL,
  printRep = ifelse(rep <= 10, 1, round(rep/10)),
  n = NULL,
  nCores = 1,
  useParLapply = FALSE,
  cl = NULL,
  stopcl = is.null(cl),
  ...
)
}
\arguments{
\item{M}{A square matrix giving the adjaciency relationg between the network's nodes (aka vertexes)}

\item{k}{The number of clusters used in the generation of partitions.}

\item{rep}{The number of repetitions/different starting partitions to check.}

\item{save.initial.param}{Should the inital parameters(\code{approaches}, ...) of using \code{stochBlock} be saved. The default value is \code{TRUE}.}

\item{deleteMs}{Delete networks/matrices from the results of to save space. Defaults to \code{TRUE}.}

\item{max.iden}{Maximum number of results that should be saved (in case there are more than \code{max.iden} results with minimal error, only the first \code{max.iden} will be saved).}

\item{return.all}{If \code{FALSE}, solution for only the best (one or more) partition/s is/are returned.}

\item{return.err}{Should the error for each optimized partition be returned. Defaults to \code{TRUE}.}

\item{seed}{Optional. The seed for random generation of partitions.}

\item{RandomSeed}{Optional. Integer vector, containing the random number generator. It is only looked for in the user's workspace.}

\item{parGenFun}{The function (object) that will generate random partitions. The default function is   \code{\link{genRandomPar}}. The function has to accept the following parameters: \code{k} (number o of partitions by modes, \code{n} (number of units by modes), \code{seed} (seed value for random generation of partition), \code{addParam} (a list of additional parameters).}

\item{mingr}{Minimal allowed group size.}

\item{maxgr}{Maximal allowed group size.}

\item{addParam}{A list of additional parameters for function specified above. In the usage section they are specified for the default function \code{\link{genRandomPar}}.}

\item{maxTriesToFindNewPar}{The maximum number of partition try when trying to find a new partition to optimize that was not yet checked before - the default value is \code{rep * 1000}.}

\item{skip.par}{The partitions that are not allowed or were already checked and should therefore be skipped.}

\item{printRep}{Should some information about each optimization be printed.}

\item{n}{The number of units by "modes". It is used only for generating random partitions. It has to be set only if there are more than two modes or if there are two modes, but the matrix representing the network is one mode (both modes are in rows and columns).}

\item{nCores}{Number of cores to be used. Value \code{0} means all available cores. It can also be a cluster object.}

\item{useParLapply}{Should \code{parLapplyLB} be used (otherwise \code{mforeach} is used). Defaults to true as it needs less dependencies. It might be removed in future releses and only allow the use of parLapplyLB.}

\item{cl}{The cluster to use (if formed beforehand). Defaults to \code{NULL}.}

\item{stopcl}{Should the cluster be stoped after the function finishes. Defaults to \code{is.null(cl)}.}

\item{\dots}{Arguments passed to other functions, see \code{\link{stochBlock}}.}
}
\value{
A list similar to optRandomParC
}
\description{
A function for optimizing multiple random partitions using stochastic one-mode and linked blockmodeling. Similar to optRandomParC, but calling stochBlock for optimizing individual partitions.
}
\examples{
# Simple one-mode network
library(blockmodeling)
k<-2
blockSizes<-rep(20,k)
IM<-matrix(c(0.8,.4,0.2,0.8), nrow=2)
if(any(dim(IM)!=c(k,k))) stop("invalid dimmensions")

set.seed(2021)
clu<-rep(1:k, times=blockSizes)
n<-length(clu)
M<-matrix(rbinom(n*n,1,IM[clu,clu]),ncol=n, nrow=n)
diag(M)<-0
plotMat(M)

resORP<-stochBlockORP(M,k=2, rep=10, return.all = TRUE)
resORP$ICL
plot(resORP)
clu(resORP)


# Linked network
library(blockmodeling)
set.seed(2021)
IM<-matrix(c(0.8,.4,0.2,0.8), nrow=2)
clu<-rep(1:2, each=20)
n<-length(clu)
nClu<-length(unique(clu))
M1<-matrix(rbinom(n^2,1,IM[clu,clu]),ncol=n, nrow=n)
M2<-matrix(rbinom(n^2,1,IM[clu,clu]),ncol=n, nrow=n)
M12<-diag(n)
nn<-c(n,n)
k<-c(2,2)
Ml<-matrix(0, nrow=sum(nn),ncol=sum(nn))
Ml[1:n,1:n]<-M1
Ml[n+1:n,n+1:n]<-M2
Ml[n+1:n, 1:n]<-M12
plotMat(Ml)

resMl<-stochBlockORP(M=Ml, k=k, n=nn, rep=10)
resMl$ICL
plot(resMl)
clu(resMl)

}
\author{
\enc{Aleš, Žiberna}{Ales Ziberna}
}
